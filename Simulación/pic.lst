CCS PCM C Compiler, Version 5.025, 41044               03-dic.-21 01:12

               Filename:   C:\Users\kit_5\Downloads\Instrumentación\Proyecto 3 - Llenado tinaco\Simulación\pic.lst

               ROM used:   1305 words (16%)
                           Largest free fragment is 2048
               RAM used:   29 (8%) at main() level
                           66 (18%) worst case
               Stack used: 3 locations (2 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   453
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   031
.................... #include <16f877a.h> 
.................... //////////// Standard Header file for the PIC16F877A device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F877A 
*
0045:  CLRF   78
0046:  CLRF   79
0047:  CLRF   77
0048:  CLRF   7A
0049:  MOVF   5B,W
004A:  BTFSS  03.2
004B:  GOTO   04F
004C:  MOVF   5A,W
004D:  BTFSC  03.2
004E:  GOTO   069
004F:  MOVLW  10
0050:  MOVWF  5C
0051:  BCF    03.0
0052:  RLF    58,F
0053:  RLF    59,F
0054:  RLF    77,F
0055:  RLF    7A,F
0056:  MOVF   5B,W
0057:  SUBWF  7A,W
0058:  BTFSS  03.2
0059:  GOTO   05C
005A:  MOVF   5A,W
005B:  SUBWF  77,W
005C:  BTFSS  03.0
005D:  GOTO   065
005E:  MOVF   5A,W
005F:  SUBWF  77,F
0060:  BTFSS  03.0
0061:  DECF   7A,F
0062:  MOVF   5B,W
0063:  SUBWF  7A,F
0064:  BSF    03.0
0065:  RLF    78,F
0066:  RLF    79,F
0067:  DECFSZ 5C,F
0068:  GOTO   051
*
0071:  MOVLW  8E
0072:  MOVWF  77
0073:  MOVF   43,W
0074:  MOVWF  78
0075:  MOVF   42,W
0076:  MOVWF  79
0077:  CLRF   7A
0078:  MOVF   78,F
0079:  BTFSS  03.2
007A:  GOTO   085
007B:  MOVF   79,W
007C:  MOVWF  78
007D:  CLRF   79
007E:  MOVLW  08
007F:  SUBWF  77,F
0080:  MOVF   78,F
0081:  BTFSS  03.2
0082:  GOTO   085
0083:  CLRF   77
0084:  GOTO   08D
0085:  BCF    03.0
0086:  BTFSC  78.7
0087:  GOTO   08C
0088:  RLF    79,F
0089:  RLF    78,F
008A:  DECF   77,F
008B:  GOTO   085
008C:  BCF    78.7
008D:  RETURN
008E:  MOVF   49,W
008F:  BTFSC  03.2
0090:  GOTO   0FE
0091:  MOVWF  51
0092:  MOVF   4D,W
0093:  BTFSC  03.2
0094:  GOTO   0FE
0095:  ADDWF  51,F
0096:  BTFSC  03.0
0097:  GOTO   09F
0098:  MOVLW  7F
0099:  SUBWF  51,F
009A:  BTFSS  03.0
009B:  GOTO   0FE
009C:  BTFSC  03.2
009D:  GOTO   0FE
009E:  GOTO   0A3
009F:  MOVLW  81
00A0:  ADDWF  51,F
00A1:  BTFSC  03.0
00A2:  GOTO   0FE
00A3:  MOVF   51,W
00A4:  MOVWF  77
00A5:  CLRF   78
00A6:  CLRF   79
00A7:  CLRF   7A
00A8:  MOVF   4A,W
00A9:  MOVWF  55
00AA:  BSF    55.7
00AB:  MOVF   4B,W
00AC:  MOVWF  54
00AD:  MOVF   4C,W
00AE:  MOVWF  53
00AF:  MOVLW  18
00B0:  MOVWF  51
00B1:  CLRF   52
00B2:  BTFSS  53.0
00B3:  GOTO   0CC
00B4:  MOVF   50,W
00B5:  ADDWF  7A,F
00B6:  BTFSS  03.0
00B7:  GOTO   0BE
00B8:  INCF   79,F
00B9:  BTFSS  03.2
00BA:  GOTO   0BE
00BB:  INCF   78,F
00BC:  BTFSC  03.2
00BD:  BSF    52.7
00BE:  MOVF   4F,W
00BF:  ADDWF  79,F
00C0:  BTFSS  03.0
00C1:  GOTO   0C5
00C2:  INCF   78,F
00C3:  BTFSC  03.2
00C4:  BSF    52.7
00C5:  MOVF   4E,W
00C6:  MOVWF  4B
00C7:  BSF    4B.7
00C8:  MOVF   4B,W
00C9:  ADDWF  78,F
00CA:  BTFSC  03.0
00CB:  BSF    52.7
00CC:  RLF    52,F
00CD:  RRF    78,F
00CE:  RRF    79,F
00CF:  RRF    7A,F
00D0:  RRF    55,F
00D1:  RRF    54,F
00D2:  RRF    53,F
00D3:  BCF    03.0
00D4:  DECFSZ 51,F
00D5:  GOTO   0B1
00D6:  MOVLW  01
00D7:  ADDWF  77,F
00D8:  BTFSC  03.0
00D9:  GOTO   0FE
00DA:  BTFSC  78.7
00DB:  GOTO   0E3
00DC:  RLF    55,F
00DD:  RLF    7A,F
00DE:  RLF    79,F
00DF:  RLF    78,F
00E0:  DECF   77,F
00E1:  BTFSC  03.2
00E2:  GOTO   0FE
00E3:  BTFSS  55.7
00E4:  GOTO   0F4
00E5:  INCF   7A,F
00E6:  BTFSS  03.2
00E7:  GOTO   0F4
00E8:  INCF   79,F
00E9:  BTFSS  03.2
00EA:  GOTO   0F4
00EB:  INCF   78,F
00EC:  BTFSS  03.2
00ED:  GOTO   0F4
00EE:  RRF    78,F
00EF:  RRF    79,F
00F0:  RRF    7A,F
00F1:  INCF   77,F
00F2:  BTFSC  03.2
00F3:  GOTO   0FE
00F4:  MOVF   4A,W
00F5:  MOVWF  52
00F6:  MOVF   4E,W
00F7:  XORWF  52,F
00F8:  BTFSS  52.7
00F9:  GOTO   0FC
00FA:  BSF    78.7
00FB:  GOTO   102
00FC:  BCF    78.7
00FD:  GOTO   102
00FE:  CLRF   77
00FF:  CLRF   78
0100:  CLRF   79
0101:  CLRF   7A
0102:  RETURN
0103:  MOVF   44,W
0104:  BTFSC  03.2
0105:  GOTO   1C8
0106:  MOVWF  50
0107:  MOVF   48,W
0108:  BTFSC  03.2
0109:  GOTO   1C8
010A:  SUBWF  50,F
010B:  BTFSS  03.0
010C:  GOTO   112
010D:  MOVLW  7F
010E:  ADDWF  50,F
010F:  BTFSC  03.0
0110:  GOTO   1C8
0111:  GOTO   118
0112:  MOVLW  81
0113:  SUBWF  50,F
0114:  BTFSS  03.0
0115:  GOTO   1C8
0116:  BTFSC  03.2
0117:  GOTO   1C8
0118:  MOVF   50,W
0119:  MOVWF  77
011A:  CLRF   78
011B:  CLRF   79
011C:  CLRF   7A
011D:  CLRF   4F
011E:  MOVF   45,W
011F:  MOVWF  4E
0120:  BSF    4E.7
0121:  MOVF   46,W
0122:  MOVWF  4D
0123:  MOVF   47,W
0124:  MOVWF  4C
0125:  MOVLW  19
0126:  MOVWF  50
0127:  MOVF   4B,W
0128:  SUBWF  4C,F
0129:  BTFSC  03.0
012A:  GOTO   13B
012B:  MOVLW  01
012C:  SUBWF  4D,F
012D:  BTFSC  03.0
012E:  GOTO   13B
012F:  SUBWF  4E,F
0130:  BTFSC  03.0
0131:  GOTO   13B
0132:  SUBWF  4F,F
0133:  BTFSC  03.0
0134:  GOTO   13B
0135:  INCF   4F,F
0136:  INCF   4E,F
0137:  INCF   4D,F
0138:  MOVF   4B,W
0139:  ADDWF  4C,F
013A:  GOTO   16D
013B:  MOVF   4A,W
013C:  SUBWF  4D,F
013D:  BTFSC  03.0
013E:  GOTO   156
013F:  MOVLW  01
0140:  SUBWF  4E,F
0141:  BTFSC  03.0
0142:  GOTO   156
0143:  SUBWF  4F,F
0144:  BTFSC  03.0
0145:  GOTO   156
0146:  INCF   4F,F
0147:  INCF   4E,F
0148:  MOVF   4A,W
0149:  ADDWF  4D,F
014A:  MOVF   4B,W
014B:  ADDWF  4C,F
014C:  BTFSS  03.0
014D:  GOTO   16D
014E:  INCF   4D,F
014F:  BTFSS  03.2
0150:  GOTO   16D
0151:  INCF   4E,F
0152:  BTFSS  03.2
0153:  GOTO   16D
0154:  INCF   4F,F
0155:  GOTO   16D
0156:  MOVF   49,W
0157:  IORLW  80
0158:  SUBWF  4E,F
0159:  BTFSC  03.0
015A:  GOTO   16C
015B:  MOVLW  01
015C:  SUBWF  4F,F
015D:  BTFSC  03.0
015E:  GOTO   16C
015F:  INCF   4F,F
0160:  MOVF   49,W
0161:  IORLW  80
0162:  ADDWF  4E,F
0163:  MOVF   4A,W
0164:  ADDWF  4D,F
0165:  BTFSS  03.0
0166:  GOTO   14A
0167:  INCF   4E,F
0168:  BTFSS  03.2
0169:  GOTO   14A
016A:  INCF   4F,F
016B:  GOTO   14A
016C:  BSF    7A.0
016D:  DECFSZ 50,F
016E:  GOTO   170
016F:  GOTO   17B
0170:  BCF    03.0
0171:  RLF    4C,F
0172:  RLF    4D,F
0173:  RLF    4E,F
0174:  RLF    4F,F
0175:  BCF    03.0
0176:  RLF    7A,F
0177:  RLF    79,F
0178:  RLF    78,F
0179:  RLF    51,F
017A:  GOTO   127
017B:  BTFSS  51.0
017C:  GOTO   183
017D:  BCF    03.0
017E:  RRF    78,F
017F:  RRF    79,F
0180:  RRF    7A,F
0181:  RRF    51,F
0182:  GOTO   186
0183:  DECF   77,F
0184:  BTFSC  03.2
0185:  GOTO   1C8
0186:  BTFSC  51.7
0187:  GOTO   1AF
0188:  BCF    03.0
0189:  RLF    4C,F
018A:  RLF    4D,F
018B:  RLF    4E,F
018C:  RLF    4F,F
018D:  MOVF   4B,W
018E:  SUBWF  4C,F
018F:  BTFSC  03.0
0190:  GOTO   19B
0191:  MOVLW  01
0192:  SUBWF  4D,F
0193:  BTFSC  03.0
0194:  GOTO   19B
0195:  SUBWF  4E,F
0196:  BTFSC  03.0
0197:  GOTO   19B
0198:  SUBWF  4F,F
0199:  BTFSS  03.0
019A:  GOTO   1BE
019B:  MOVF   4A,W
019C:  SUBWF  4D,F
019D:  BTFSC  03.0
019E:  GOTO   1A6
019F:  MOVLW  01
01A0:  SUBWF  4E,F
01A1:  BTFSC  03.0
01A2:  GOTO   1A6
01A3:  SUBWF  4F,F
01A4:  BTFSS  03.0
01A5:  GOTO   1BE
01A6:  MOVF   49,W
01A7:  IORLW  80
01A8:  SUBWF  4E,F
01A9:  BTFSC  03.0
01AA:  GOTO   1AF
01AB:  MOVLW  01
01AC:  SUBWF  4F,F
01AD:  BTFSS  03.0
01AE:  GOTO   1BE
01AF:  INCF   7A,F
01B0:  BTFSS  03.2
01B1:  GOTO   1BE
01B2:  INCF   79,F
01B3:  BTFSS  03.2
01B4:  GOTO   1BE
01B5:  INCF   78,F
01B6:  BTFSS  03.2
01B7:  GOTO   1BE
01B8:  INCF   77,F
01B9:  BTFSC  03.2
01BA:  GOTO   1C8
01BB:  RRF    78,F
01BC:  RRF    79,F
01BD:  RRF    7A,F
01BE:  MOVF   45,W
01BF:  MOVWF  50
01C0:  MOVF   49,W
01C1:  XORWF  50,F
01C2:  BTFSS  50.7
01C3:  GOTO   1C6
01C4:  BSF    78.7
01C5:  GOTO   1CC
01C6:  BCF    78.7
01C7:  GOTO   1CC
01C8:  CLRF   77
01C9:  CLRF   78
01CA:  CLRF   79
01CB:  CLRF   7A
01CC:  RETURN
*
0276:  MOVLW  8E
0277:  MOVWF  77
0278:  MOVF   3C,W
0279:  SUBWF  77,F
027A:  MOVF   3D,W
027B:  MOVWF  79
027C:  MOVF   3E,W
027D:  MOVWF  78
027E:  BSF    79.7
027F:  MOVF   77,F
0280:  BTFSC  03.2
0281:  GOTO   28D
0282:  BCF    03.0
0283:  MOVF   79,F
0284:  BTFSS  03.2
0285:  GOTO   289
0286:  MOVF   78,F
0287:  BTFSC  03.2
0288:  GOTO   28D
0289:  RRF    79,F
028A:  RRF    78,F
028B:  DECFSZ 77,F
028C:  GOTO   282
028D:  BTFSS  3D.7
028E:  GOTO   294
028F:  COMF   78,F
0290:  COMF   79,F
0291:  INCF   78,F
0292:  BTFSC  03.2
0293:  INCF   79,F
0294:  BCF    0A.3
0295:  BCF    0A.4
0296:  GOTO   4DF (RETURN)
0297:  MOVF   43,W
0298:  CLRF   78
0299:  SUBWF  42,W
029A:  BTFSC  03.0
029B:  GOTO   29F
029C:  MOVF   42,W
029D:  MOVWF  77
029E:  GOTO   2AB
029F:  CLRF   77
02A0:  MOVLW  08
02A1:  MOVWF  44
02A2:  RLF    42,F
02A3:  RLF    77,F
02A4:  MOVF   43,W
02A5:  SUBWF  77,W
02A6:  BTFSC  03.0
02A7:  MOVWF  77
02A8:  RLF    78,F
02A9:  DECFSZ 44,F
02AA:  GOTO   2A2
02AB:  RETURN
02AC:  MOVLW  20
02AD:  BTFSS  3D.4
02AE:  MOVLW  30
02AF:  MOVWF  3E
02B0:  MOVF   3C,W
02B1:  MOVWF  77
02B2:  BTFSS  3C.7
02B3:  GOTO   2BC
02B4:  COMF   77,F
02B5:  INCF   77,F
02B6:  MOVF   77,W
02B7:  MOVWF  3C
02B8:  MOVLW  2D
02B9:  MOVWF  3E
02BA:  BSF    3D.7
02BB:  BSF    3D.0
02BC:  MOVF   3C,W
02BD:  MOVWF  42
02BE:  MOVLW  64
02BF:  MOVWF  43
02C0:  CALL   297
02C1:  MOVF   77,W
02C2:  MOVWF  3C
02C3:  MOVLW  30
02C4:  ADDWF  78,W
02C5:  MOVWF  3F
02C6:  MOVF   3C,W
02C7:  MOVWF  42
02C8:  MOVLW  0A
02C9:  MOVWF  43
02CA:  CALL   297
02CB:  MOVLW  30
02CC:  ADDWF  77,W
02CD:  MOVWF  41
02CE:  MOVLW  30
02CF:  ADDWF  78,W
02D0:  MOVWF  40
02D1:  MOVF   3E,W
02D2:  MOVWF  77
02D3:  MOVLW  30
02D4:  SUBWF  3F,W
02D5:  BTFSC  03.2
02D6:  GOTO   2DB
02D7:  BSF    3D.1
02D8:  BTFSC  3D.7
02D9:  BSF    3D.2
02DA:  GOTO   2EF
02DB:  MOVF   3E,W
02DC:  MOVWF  3F
02DD:  MOVLW  20
02DE:  MOVWF  3E
02DF:  MOVLW  30
02E0:  SUBWF  40,W
02E1:  BTFSC  03.2
02E2:  GOTO   2E7
02E3:  BSF    3D.0
02E4:  BTFSC  3D.7
02E5:  BSF    3D.1
02E6:  GOTO   2EF
02E7:  BTFSS  03.2
02E8:  BSF    3D.0
02E9:  BTFSS  03.2
02EA:  GOTO   2EF
02EB:  MOVF   3F,W
02EC:  MOVWF  40
02ED:  MOVLW  20
02EE:  MOVWF  3F
02EF:  BTFSC  3D.2
02F0:  GOTO   2F6
02F1:  BTFSC  3D.1
02F2:  GOTO   2FA
02F3:  BTFSC  3D.0
02F4:  GOTO   2FE
02F5:  GOTO   302
02F6:  MOVF   3E,W
02F7:  BTFSS  0C.4
02F8:  GOTO   2F7
02F9:  MOVWF  19
02FA:  MOVF   3F,W
02FB:  BTFSS  0C.4
02FC:  GOTO   2FB
02FD:  MOVWF  19
02FE:  MOVF   40,W
02FF:  BTFSS  0C.4
0300:  GOTO   2FF
0301:  MOVWF  19
0302:  MOVF   41,W
0303:  BTFSS  0C.4
0304:  GOTO   303
0305:  MOVWF  19
0306:  BCF    0A.3
0307:  BCF    0A.4
0308:  GOTO   4EA (RETURN)
0309:  BTFSC  03.1
030A:  GOTO   30E
030B:  MOVLW  51
030C:  MOVWF  04
030D:  BCF    03.7
030E:  CLRF   77
030F:  CLRF   78
0310:  CLRF   79
0311:  CLRF   7A
0312:  CLRF   51
0313:  CLRF   52
0314:  CLRF   53
0315:  CLRF   54
0316:  MOVF   50,W
0317:  IORWF  4F,W
0318:  IORWF  4E,W
0319:  IORWF  4D,W
031A:  BTFSC  03.2
031B:  GOTO   34C
031C:  MOVLW  20
031D:  MOVWF  55
031E:  BCF    03.0
031F:  RLF    49,F
0320:  RLF    4A,F
0321:  RLF    4B,F
0322:  RLF    4C,F
0323:  RLF    51,F
0324:  RLF    52,F
0325:  RLF    53,F
0326:  RLF    54,F
0327:  MOVF   50,W
0328:  SUBWF  54,W
0329:  BTFSS  03.2
032A:  GOTO   335
032B:  MOVF   4F,W
032C:  SUBWF  53,W
032D:  BTFSS  03.2
032E:  GOTO   335
032F:  MOVF   4E,W
0330:  SUBWF  52,W
0331:  BTFSS  03.2
0332:  GOTO   335
0333:  MOVF   4D,W
0334:  SUBWF  51,W
0335:  BTFSS  03.0
0336:  GOTO   346
0337:  MOVF   4D,W
0338:  SUBWF  51,F
0339:  MOVF   4E,W
033A:  BTFSS  03.0
033B:  INCFSZ 4E,W
033C:  SUBWF  52,F
033D:  MOVF   4F,W
033E:  BTFSS  03.0
033F:  INCFSZ 4F,W
0340:  SUBWF  53,F
0341:  MOVF   50,W
0342:  BTFSS  03.0
0343:  INCFSZ 50,W
0344:  SUBWF  54,F
0345:  BSF    03.0
0346:  RLF    77,F
0347:  RLF    78,F
0348:  RLF    79,F
0349:  RLF    7A,F
034A:  DECFSZ 55,F
034B:  GOTO   31E
034C:  MOVF   51,W
034D:  MOVWF  00
034E:  INCF   04,F
034F:  MOVF   52,W
0350:  MOVWF  00
0351:  INCF   04,F
0352:  MOVF   53,W
0353:  MOVWF  00
0354:  INCF   04,F
0355:  MOVF   54,W
0356:  MOVWF  00
0357:  RETURN
0358:  MOVF   04,W
0359:  MOVWF  41
035A:  MOVF   40,W
035B:  MOVWF  43
035C:  BTFSC  03.2
035D:  GOTO   377
035E:  MOVF   3F,W
035F:  MOVWF  4C
0360:  MOVF   3E,W
0361:  MOVWF  4B
0362:  MOVF   3D,W
0363:  MOVWF  4A
0364:  MOVF   3C,W
0365:  MOVWF  49
0366:  CLRF   50
0367:  CLRF   4F
0368:  MOVLW  20
0369:  MOVWF  4E
036A:  MOVLW  82
036B:  MOVWF  4D
036C:  CALL   08E
036D:  MOVF   7A,W
036E:  MOVWF  3F
036F:  MOVF   79,W
0370:  MOVWF  3E
0371:  MOVF   78,W
0372:  MOVWF  3D
0373:  MOVF   77,W
0374:  MOVWF  3C
0375:  DECFSZ 43,F
0376:  GOTO   35E
0377:  MOVF   3F,W
0378:  MOVWF  4C
0379:  MOVF   3E,W
037A:  MOVWF  4B
037B:  MOVF   3D,W
037C:  MOVWF  4A
037D:  MOVF   3C,W
037E:  MOVWF  49
037F:  MOVF   49,W
0380:  SUBLW  B6
0381:  MOVWF  49
0382:  CLRF   7A
0383:  MOVF   4A,W
0384:  MOVWF  4D
0385:  BSF    4A.7
0386:  BCF    03.0
0387:  RRF    4A,F
0388:  RRF    4B,F
0389:  RRF    4C,F
038A:  RRF    7A,F
038B:  RRF    79,F
038C:  RRF    78,F
038D:  RRF    77,F
038E:  DECFSZ 49,F
038F:  GOTO   386
0390:  BTFSS  4D.7
0391:  GOTO   39D
0392:  COMF   77,F
0393:  COMF   78,F
0394:  COMF   79,F
0395:  COMF   7A,F
0396:  INCF   77,F
0397:  BTFSC  03.2
0398:  INCF   78,F
0399:  BTFSC  03.2
039A:  INCF   79,F
039B:  BTFSC  03.2
039C:  INCF   7A,F
039D:  MOVF   7A,W
039E:  MOVWF  3F
039F:  MOVF   79,W
03A0:  MOVWF  3E
03A1:  MOVF   78,W
03A2:  MOVWF  3D
03A3:  MOVF   77,W
03A4:  MOVWF  3C
03A5:  BTFSS  3F.7
03A6:  GOTO   3B4
03A7:  DECF   41,F
03A8:  BSF    41.5
03A9:  COMF   3C,F
03AA:  COMF   3D,F
03AB:  COMF   3E,F
03AC:  COMF   3F,F
03AD:  INCF   3C,F
03AE:  BTFSC  03.2
03AF:  INCF   3D,F
03B0:  BTFSC  03.2
03B1:  INCF   3E,F
03B2:  BTFSC  03.2
03B3:  INCF   3F,F
03B4:  MOVLW  3B
03B5:  MOVWF  48
03B6:  MOVLW  9A
03B7:  MOVWF  47
03B8:  MOVLW  CA
03B9:  MOVWF  46
03BA:  CLRF   45
03BB:  MOVLW  0A
03BC:  MOVWF  43
03BD:  MOVF   40,W
03BE:  BTFSC  03.2
03BF:  INCF   41,F
03C0:  BSF    03.1
03C1:  MOVLW  3C
03C2:  MOVWF  04
03C3:  BCF    03.7
03C4:  MOVF   3F,W
03C5:  MOVWF  4C
03C6:  MOVF   3E,W
03C7:  MOVWF  4B
03C8:  MOVF   3D,W
03C9:  MOVWF  4A
03CA:  MOVF   3C,W
03CB:  MOVWF  49
03CC:  MOVF   48,W
03CD:  MOVWF  50
03CE:  MOVF   47,W
03CF:  MOVWF  4F
03D0:  MOVF   46,W
03D1:  MOVWF  4E
03D2:  MOVF   45,W
03D3:  MOVWF  4D
03D4:  CALL   309
03D5:  MOVF   78,W
03D6:  MOVF   77,F
03D7:  BTFSS  03.2
03D8:  GOTO   3EC
03D9:  INCF   40,W
03DA:  SUBWF  43,W
03DB:  BTFSC  03.2
03DC:  GOTO   3EC
03DD:  MOVF   41,W
03DE:  BTFSC  03.2
03DF:  GOTO   3EE
03E0:  ANDLW  0F
03E1:  SUBWF  43,W
03E2:  BTFSC  03.2
03E3:  GOTO   3E6
03E4:  BTFSC  03.0
03E5:  GOTO   422
03E6:  BTFSC  41.7
03E7:  GOTO   422
03E8:  BTFSC  41.6
03E9:  GOTO   3EE
03EA:  MOVLW  20
03EB:  GOTO   41D
03EC:  MOVLW  20
03ED:  ANDWF  41,F
03EE:  BTFSS  41.5
03EF:  GOTO   3FD
03F0:  BCF    41.5
03F1:  MOVF   40,W
03F2:  BTFSS  03.2
03F3:  DECF   41,F
03F4:  MOVF   77,W
03F5:  MOVWF  41
03F6:  MOVLW  2D
03F7:  BTFSS  0C.4
03F8:  GOTO   3F7
03F9:  MOVWF  19
03FA:  MOVF   41,W
03FB:  MOVWF  77
03FC:  CLRF   41
03FD:  MOVF   40,W
03FE:  SUBWF  43,W
03FF:  BTFSS  03.2
0400:  GOTO   40C
0401:  MOVF   77,W
0402:  MOVWF  41
0403:  MOVLW  2E
0404:  BTFSS  0C.4
0405:  GOTO   404
0406:  MOVWF  19
0407:  MOVF   41,W
0408:  MOVWF  77
0409:  MOVLW  20
040A:  ANDWF  41,F
040B:  MOVLW  00
040C:  MOVLW  30
040D:  BTFSS  41.5
040E:  GOTO   41D
040F:  BCF    41.5
0410:  MOVF   40,W
0411:  BTFSS  03.2
0412:  DECF   41,F
0413:  MOVF   77,W
0414:  MOVWF  41
0415:  MOVLW  2D
0416:  BTFSS  0C.4
0417:  GOTO   416
0418:  MOVWF  19
0419:  MOVF   41,W
041A:  MOVWF  77
041B:  CLRF   41
041C:  MOVLW  30
041D:  ADDWF  77,F
041E:  MOVF   77,W
041F:  BTFSS  0C.4
0420:  GOTO   41F
0421:  MOVWF  19
0422:  BCF    03.1
0423:  MOVF   48,W
0424:  MOVWF  4C
0425:  MOVF   47,W
0426:  MOVWF  4B
0427:  MOVF   46,W
0428:  MOVWF  4A
0429:  MOVF   45,W
042A:  MOVWF  49
042B:  CLRF   50
042C:  CLRF   4F
042D:  CLRF   4E
042E:  MOVLW  0A
042F:  MOVWF  4D
0430:  CALL   309
0431:  MOVF   7A,W
0432:  MOVWF  48
0433:  MOVF   79,W
0434:  MOVWF  47
0435:  MOVF   78,W
0436:  MOVWF  46
0437:  MOVF   77,W
0438:  MOVWF  45
0439:  DECFSZ 43,F
043A:  GOTO   3C0
043B:  RETURN
....................  
.................... #list 
....................  
.................... #device adc=10 
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
*
0468:  BCF    03.5
0469:  CLRF   27
046A:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #fuses XT,NOWDT,NOPROTECT,NOLVP,PUT,BROWNOUT 
.................... #use DELAY (CLOCK=4MHz) 
*
043C:  MOVLW  3D
043D:  MOVWF  04
043E:  BCF    03.7
043F:  MOVF   00,W
0440:  BTFSC  03.2
0441:  GOTO   450
0442:  MOVLW  01
0443:  MOVWF  78
0444:  CLRF   77
0445:  DECFSZ 77,F
0446:  GOTO   445
0447:  DECFSZ 78,F
0448:  GOTO   444
0449:  MOVLW  4A
044A:  MOVWF  77
044B:  DECFSZ 77,F
044C:  GOTO   44B
044D:  GOTO   44E
044E:  DECFSZ 00,F
044F:  GOTO   442
0450:  BCF    0A.3
0451:  BCF    0A.4
0452:  GOTO   515 (RETURN)
.................... #use rs232 (baud=9600,parity=N,xmit=pin_c6,rcv=pin_c7,bits=8) 
....................  
.................... #DEFINE LED PORTC, 0 
.................... #BYTE PORTC = 0X07 
....................  
.................... float tiempo; 
.................... int distancia; 
.................... int dato; 
....................  
.................... int Timer2, Postcaler; 
.................... int16 duty; 
....................  
.................... void encenderLed(); 
.................... void apagarLed(); 
....................  
....................  
.................... #define trigger pin_B1 
.................... #define echo pin_B0 
.................... #int_rda // Interrupcuón por recepción de un caracter 
.................... void rda_isr(){ 
....................    dato = getc(); 
*
0031:  BTFSS  0C.5
0032:  GOTO   031
0033:  MOVF   1A,W
0034:  MOVWF  2E
....................     
....................    duty = dato*1024/200; 
0035:  CLRF   7A
0036:  MOVF   2E,W
0037:  MOVWF  79
0038:  CLRF   56
0039:  RLF    79,W
003A:  MOVWF  57
003B:  RLF    57,F
003C:  MOVLW  FC
003D:  ANDWF  57,F
003E:  MOVF   57,W
003F:  MOVWF  59
0040:  MOVF   56,W
0041:  MOVWF  58
0042:  CLRF   5B
0043:  MOVLW  C8
0044:  MOVWF  5A
*
0069:  MOVF   79,W
006A:  MOVWF  32
006B:  MOVF   78,W
006C:  MOVWF  31
006D:  BCF    0C.5
006E:  BCF    0A.3
006F:  BCF    0A.4
0070:  GOTO   01D
.................... } 
....................  
.................... void encenderLed(){ 
....................    Set_Tris_C(0b11111110); // Se configura el bit 0 del puerto B como salida 
....................    bit_set(LED); 
....................    delay_ms(1000); 
....................    Bit_clear(LED);; 
.................... } 
....................  
.................... void apagarLed(){ 
....................    Bit_clear(LED); 
.................... } 
.................... float leersensor1(){ 
....................    float valor; 
....................    setup_adc_ports(ALL_ANALOG); 
*
01CD:  BSF    03.5
01CE:  BCF    1F.0
01CF:  BCF    1F.1
01D0:  BCF    1F.2
01D1:  BCF    1F.3
....................    setup_adc(adc_clock_div_16); 
01D2:  BSF    1F.6
01D3:  BCF    03.5
01D4:  BSF    1F.6
01D5:  BCF    1F.7
01D6:  BSF    03.5
01D7:  BSF    1F.7
01D8:  BCF    03.5
01D9:  BSF    1F.0
....................     
....................    set_adc_channel(0); 
01DA:  MOVLW  00
01DB:  MOVWF  78
01DC:  MOVF   1F,W
01DD:  ANDLW  C7
01DE:  IORWF  78,W
01DF:  MOVWF  1F
....................    delay_us(50); 
01E0:  MOVLW  10
01E1:  MOVWF  77
01E2:  DECFSZ 77,F
01E3:  GOTO   1E2
01E4:  NOP
....................    valor = ((read_adc())*100.0/1023); 
01E5:  BSF    1F.2
01E6:  BTFSC  1F.2
01E7:  GOTO   1E6
01E8:  MOVF   1E,W
01E9:  MOVWF  7A
01EA:  BSF    03.5
01EB:  MOVF   1E,W
01EC:  BCF    03.5
01ED:  MOVWF  40
01EE:  MOVF   1E,W
01EF:  MOVWF  41
01F0:  MOVWF  43
01F1:  MOVF   40,W
01F2:  MOVWF  42
01F3:  CALL   071
01F4:  MOVF   7A,W
01F5:  MOVWF  4C
01F6:  MOVF   79,W
01F7:  MOVWF  4B
01F8:  MOVF   78,W
01F9:  MOVWF  4A
01FA:  MOVF   77,W
01FB:  MOVWF  49
01FC:  CLRF   50
01FD:  CLRF   4F
01FE:  MOVLW  48
01FF:  MOVWF  4E
0200:  MOVLW  85
0201:  MOVWF  4D
0202:  CALL   08E
0203:  MOVF   7A,W
0204:  MOVWF  43
0205:  MOVF   79,W
0206:  MOVWF  42
0207:  MOVF   78,W
0208:  MOVWF  41
0209:  MOVF   77,W
020A:  MOVWF  40
020B:  MOVF   7A,W
020C:  MOVWF  47
020D:  MOVF   79,W
020E:  MOVWF  46
020F:  MOVF   78,W
0210:  MOVWF  45
0211:  MOVF   77,W
0212:  MOVWF  44
0213:  CLRF   4B
0214:  MOVLW  C0
0215:  MOVWF  4A
0216:  MOVLW  7F
0217:  MOVWF  49
0218:  MOVLW  88
0219:  MOVWF  48
021A:  CALL   103
021B:  MOVF   7A,W
021C:  MOVWF  3F
021D:  MOVF   79,W
021E:  MOVWF  3E
021F:  MOVF   78,W
0220:  MOVWF  3D
0221:  MOVF   77,W
0222:  MOVWF  3C
....................    return valor; 
0223:  MOVF   3C,W
0224:  MOVWF  77
0225:  MOVF   3D,W
0226:  MOVWF  78
0227:  MOVF   3E,W
0228:  MOVWF  79
0229:  MOVF   3F,W
022A:  MOVWF  7A
022B:  BCF    0A.3
022C:  BCF    0A.4
022D:  GOTO   47C (RETURN)
.................... } 
....................  
.................... float leersensor2(){ 
....................    float valor; 
....................    setup_adc_ports(ALL_ANALOG); 
022E:  BSF    03.5
022F:  BCF    1F.0
0230:  BCF    1F.1
0231:  BCF    1F.2
0232:  BCF    1F.3
....................    setup_adc(adc_clock_div_16); 
0233:  BSF    1F.6
0234:  BCF    03.5
0235:  BSF    1F.6
0236:  BCF    1F.7
0237:  BSF    03.5
0238:  BSF    1F.7
0239:  BCF    03.5
023A:  BSF    1F.0
....................     
....................    set_adc_channel(1);   
023B:  MOVLW  08
023C:  MOVWF  78
023D:  MOVF   1F,W
023E:  ANDLW  C7
023F:  IORWF  78,W
0240:  MOVWF  1F
....................    delay_us(50); 
0241:  MOVLW  10
0242:  MOVWF  77
0243:  DECFSZ 77,F
0244:  GOTO   243
0245:  NOP
....................    valor = ((read_adc()*1.0)); 
0246:  BSF    1F.2
0247:  BTFSC  1F.2
0248:  GOTO   247
0249:  MOVF   1E,W
024A:  MOVWF  7A
024B:  BSF    03.5
024C:  MOVF   1E,W
024D:  BCF    03.5
024E:  MOVWF  40
024F:  MOVF   1E,W
0250:  MOVWF  41
0251:  MOVWF  43
0252:  MOVF   40,W
0253:  MOVWF  42
0254:  CALL   071
0255:  MOVF   7A,W
0256:  MOVWF  4C
0257:  MOVF   79,W
0258:  MOVWF  4B
0259:  MOVF   78,W
025A:  MOVWF  4A
025B:  MOVF   77,W
025C:  MOVWF  49
025D:  CLRF   50
025E:  CLRF   4F
025F:  CLRF   4E
0260:  MOVLW  7F
0261:  MOVWF  4D
0262:  CALL   08E
0263:  MOVF   7A,W
0264:  MOVWF  3F
0265:  MOVF   79,W
0266:  MOVWF  3E
0267:  MOVF   78,W
0268:  MOVWF  3D
0269:  MOVF   77,W
026A:  MOVWF  3C
....................    return valor;    
026B:  MOVF   3C,W
026C:  MOVWF  77
026D:  MOVF   3D,W
026E:  MOVWF  78
026F:  MOVF   3E,W
0270:  MOVWF  79
0271:  MOVF   3F,W
0272:  MOVWF  7A
0273:  BCF    0A.3
0274:  BCF    0A.4
0275:  GOTO   485 (RETURN)
.................... } 
....................  
.................... void main(){ 
*
0453:  MOVF   03,W
0454:  ANDLW  1F
0455:  MOVWF  03
0456:  MOVLW  19
0457:  BSF    03.5
0458:  MOVWF  19
0459:  MOVLW  A6
045A:  MOVWF  18
045B:  MOVLW  90
045C:  BCF    03.5
045D:  MOVWF  18
045E:  MOVLW  FF
045F:  MOVWF  33
0460:  BSF    03.5
0461:  BSF    1F.0
0462:  BSF    1F.1
0463:  BSF    1F.2
0464:  BCF    1F.3
0465:  MOVLW  07
0466:  MOVWF  1C
0467:  BCF    03.7
....................    //enable_interrupts(int_rda); 
....................    //enable_interrupts(global); 
....................    setup_timer_1(T1_internal|T1_div_by_1);    
*
046B:  MOVLW  85
046C:  MOVWF  10
....................  
....................    while(true){ 
....................       output_high(trigger); 
046D:  BSF    03.5
046E:  BCF    06.1
046F:  BCF    03.5
0470:  BSF    06.1
....................       delay_us(10); 
0471:  MOVLW  02
0472:  MOVWF  77
0473:  DECFSZ 77,F
0474:  GOTO   473
0475:  GOTO   476
0476:  NOP
....................       output_low(trigger); 
0477:  BSF    03.5
0478:  BCF    06.1
0479:  BCF    03.5
047A:  BCF    06.1
....................        
....................       float dato_1 = leersensor1(); 
....................       float dato_2 = leersensor2(); 
047B:  GOTO   1CD
047C:  MOVF   7A,W
047D:  MOVWF  37
047E:  MOVF   79,W
047F:  MOVWF  36
0480:  MOVF   78,W
0481:  MOVWF  35
0482:  MOVF   77,W
0483:  MOVWF  34
0484:  GOTO   22E
0485:  MOVF   7A,W
0486:  MOVWF  3B
0487:  MOVF   79,W
0488:  MOVWF  3A
0489:  MOVF   78,W
048A:  MOVWF  39
048B:  MOVF   77,W
048C:  MOVWF  38
....................        
....................       while(!input(echo)); 
048D:  BSF    03.5
048E:  BSF    06.0
048F:  BCF    03.5
0490:  BTFSS  06.0
0491:  GOTO   48D
....................       set_timer1(0); 
0492:  CLRF   0E
0493:  CLRF   0F
0494:  CLRF   0E
....................        
....................       while(input(echo)); 
0495:  BSF    03.5
0496:  BSF    06.0
0497:  BCF    03.5
0498:  BTFSC  06.0
0499:  GOTO   495
....................       tiempo = get_timer1(); 
049A:  MOVF   0F,W
049B:  MOVWF  7A
049C:  MOVF   0E,W
049D:  MOVWF  77
049E:  MOVF   0F,W
049F:  SUBWF  7A,W
04A0:  BTFSS  03.2
04A1:  GOTO   49A
04A2:  MOVF   77,W
04A3:  MOVWF  42
04A4:  MOVF   7A,W
04A5:  MOVWF  43
04A6:  CALL   071
04A7:  MOVF   7A,W
04A8:  MOVWF  2C
04A9:  MOVF   79,W
04AA:  MOVWF  2B
04AB:  MOVF   78,W
04AC:  MOVWF  2A
04AD:  MOVF   77,W
04AE:  MOVWF  29
....................       distancia=(tiempo/2)*(0.0343); 
04AF:  MOVF   2C,W
04B0:  MOVWF  47
04B1:  MOVF   2B,W
04B2:  MOVWF  46
04B3:  MOVF   2A,W
04B4:  MOVWF  45
04B5:  MOVF   29,W
04B6:  MOVWF  44
04B7:  CLRF   4B
04B8:  CLRF   4A
04B9:  CLRF   49
04BA:  MOVLW  80
04BB:  MOVWF  48
04BC:  CALL   103
04BD:  MOVF   7A,W
04BE:  MOVWF  3F
04BF:  MOVF   79,W
04C0:  MOVWF  3E
04C1:  MOVF   78,W
04C2:  MOVWF  3D
04C3:  MOVF   77,W
04C4:  MOVWF  3C
04C5:  MOVF   7A,W
04C6:  MOVWF  4C
04C7:  MOVF   79,W
04C8:  MOVWF  4B
04C9:  MOVF   78,W
04CA:  MOVWF  4A
04CB:  MOVF   77,W
04CC:  MOVWF  49
04CD:  MOVLW  28
04CE:  MOVWF  50
04CF:  MOVLW  7E
04D0:  MOVWF  4F
04D1:  MOVLW  0C
04D2:  MOVWF  4E
04D3:  MOVLW  7A
04D4:  MOVWF  4D
04D5:  CALL   08E
04D6:  MOVF   7A,W
04D7:  MOVWF  3F
04D8:  MOVF   79,W
04D9:  MOVWF  3E
04DA:  MOVF   78,W
04DB:  MOVWF  3D
04DC:  MOVF   77,W
04DD:  MOVWF  3C
04DE:  GOTO   276
04DF:  MOVF   78,W
04E0:  MOVWF  2D
....................        
....................       //printf("Hola"); 
....................       printf("\ %d %f %f\n", distancia, dato_1, dato_2); 
04E1:  MOVLW  20
04E2:  BTFSS  0C.4
04E3:  GOTO   4E2
04E4:  MOVWF  19
04E5:  MOVF   2D,W
04E6:  MOVWF  3C
04E7:  MOVLW  18
04E8:  MOVWF  3D
04E9:  GOTO   2AC
04EA:  MOVLW  20
04EB:  BTFSS  0C.4
04EC:  GOTO   4EB
04ED:  MOVWF  19
04EE:  MOVLW  89
04EF:  MOVWF  04
04F0:  MOVF   37,W
04F1:  MOVWF  3F
04F2:  MOVF   36,W
04F3:  MOVWF  3E
04F4:  MOVF   35,W
04F5:  MOVWF  3D
04F6:  MOVF   34,W
04F7:  MOVWF  3C
04F8:  MOVLW  02
04F9:  MOVWF  40
04FA:  CALL   358
04FB:  MOVLW  20
04FC:  BTFSS  0C.4
04FD:  GOTO   4FC
04FE:  MOVWF  19
04FF:  MOVLW  89
0500:  MOVWF  04
0501:  MOVF   3B,W
0502:  MOVWF  3F
0503:  MOVF   3A,W
0504:  MOVWF  3E
0505:  MOVF   39,W
0506:  MOVWF  3D
0507:  MOVF   38,W
0508:  MOVWF  3C
0509:  MOVLW  02
050A:  MOVWF  40
050B:  CALL   358
050C:  MOVLW  0A
050D:  BTFSS  0C.4
050E:  GOTO   50D
050F:  MOVWF  19
....................       //putc(distancia); 
....................       //putc(dato_1); 
....................        
....................       delay_ms(500); 
0510:  MOVLW  02
0511:  MOVWF  3C
0512:  MOVLW  FA
0513:  MOVWF  3D
0514:  GOTO   43C
0515:  DECFSZ 3C,F
0516:  GOTO   512
0517:  GOTO   46D
....................    } 
.................... } 
0518:  SLEEP

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
